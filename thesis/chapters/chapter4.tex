\chapter{Kodowanie problemów}

Niniejszy rozdział wprowadza czytelnika do 12 wybranych problemów w teorii grafów i optymalizacji, takich jak:
Ścieżka Hamiltona w grafie skierowanym,
Ścieżka Hamiltona w grafie nieskierowanym, 
Izomorfizm grafów, 
Pokrycie wierzchołkowe (ang. Vertex Cover), 
Problem kliki (ang. The maximum clique size problem), 
Problem pokrycia zbioru (ang. Set Cover), 
Problem maksymalnego zbioru niezależnego (ang. Maximum Independent Set), 
Problem Komiwojażera, 
Kolorowanie grafu, 
Problem sumy podzbioru (ang. SubsetSum), 
Drzewo Steinera (ang. Steiner Tree), 
Problem plecakowy, 
Problem najbliższego ciągu (ang. Closest string).

Każdy problem, który analizuję w mojej pracy, jest kodowany jako zestaw ograniczeń logicznych, które definiują jego specyfikację i warunki jego rozwiązania. Wykorzystanie tego podejścia pozwala mi na elastyczne definiowanie problemów, wyrażanie ich w sposób zrozumiały dla maszyny, a także szybkie eksperymentowanie z różnymi zestawami ograniczeń oraz łatwe wprowadzanie zmian w modelach problemów.

Każda sekcja zawiera opis algorytmu oraz kod demonstracyjny w języku Python z wykorzystaniem biblioteki Z3 do rozwiązania tych problemów.

\section{Problem ścieżki Hamiltona}

Problem ścieżki Hamiltona jest zagadnieniem z zakresu teorii złożoności i teorii grafów. Rozstrzyga on, czy graf zawiera ścieżkę Hamiltona, czyli ścieżkę, która odwiedza każdy wierzchołek grafu dokładnie raz.

Problem ścieżki Hamiltona ma zastosowanie w wielu dziedzinach, takich jak informatyka, telekomunikacja czy bioinformatyka. Rozwiązanie tego problemu jest często kluczowe w analizie sieci i trasowania w systemach komunikacyjnych \cite{enwiki:1190136070}.

\subsection{Ścieżka Hamiltona w grafie skierowanym}

Dla grafu skierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem wierzchołków.
	\item \(E\) jest zbiorem skierowanych krawędzi.
\end{itemize}
Ścieżka Hamiltona jest sekwencją wierzchołków $v_1, v_2, …, v_n$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(v_i\) i \(v_{i+1}\) w sekwencji istnieje skierowana krawędź od \(v_i\) do \(v_{i+1}\) w \(E\). 
\end{enumerate}

Dodatkowo, ścieżka Hamiltona może zaczynać się z dowolnego wierzchołka i kończyć w dowolnym innym wierzchołku.

Kodowanie problemu ścieżki Hamiltona opiera się na formułowaniu ograniczeń logicznych, które muszą zostać spełnione, aby znaleźć poszukiwaną ścieżkę Hamiltona. W tym celu definiuje się cztery funkcje: 'check\verb|_|hampath', 'proper\verb|_|numbers', 'distinct\verb|_|vs' oraz 'edge'. Funkcja 'check\verb|_|hampath' odpowiada za główny algorytm rozwiązujący problem. Pozostałe funkcje służą do generowania ograniczeń logicznych.

Pierwszą z funkcji, która została wykorzystana w modelowaniu problemu, jest funkcja 'proper\verb|_|numbers', która ma na celu zapewnienie, że wartości przypisane do zmiennych 'vertices' ($v_1, v_2, …, v_n$) reprezentujące wierzchołki grafu są w zakresie od $1$ do $n$, gdzie $n$ to liczba wierzchołków w grafie. Poniższa formuła logiczna określa przypisanie odpowiednich wartości wierzchołkóm:

\begin{align*}
	\mli{proper\textunderscore numbers}(n) = \left( \bigwedge_{j=0}^{n-1} (v_j \geq 1 \land v_j \leq n) \right) 
\end{align*}

\begin{lstlisting}
	def proper_numbers(vertices):
	n = len(vertices)
	atoms = []
	for i in range(n - 1):
	atoms.append(z3.And(vertices[i] >= 0, vertices[i] < n))
	bf = z3.And(atoms)
	return bf
\end{lstlisting}
\vspace{1cm}

Kolejna funkcja 'distinct\verb|_|vs' zapewnia, że każdy wierzchołek grafu jest odwiedziany dokładnie raz, czyli żadne dwa wierzchołki nie mają tej samej wartości:

\begin{align*}
	\mli{distinct\textunderscore vs}(n) = \left( \bigwedge_{i=0}^{n-1} \bigwedge_{j=i+1}^{n} (v_i \neq v_j) \right)
\end{align*}

\begin{lstlisting}	
	def distinct_vs(vertices):
	n = len(vertices)
	atoms = []
	for i in range(n - 1):
	for j in range(i + 1, n):
	atoms.append(vertices[i] != vertices[j])
	bf = z3.And(atoms)
	return bf
\end{lstlisting}
\vspace{1cm}

Funkcja 'edge' generuje ograniczenia logiczne dla krawędzi między wierzchołkami na podstawie podanego grafu. Niech $v_1, v_2, …, v_n$ to wierzchołki grafu, a \(E\) to zbiór wszystkich krawędzi, w przypadku grafu skierowanego zbiór uporządkowanych par (s, t), gdzie pierwsza zmienna s oznacza punkt źródłowy krawędzi, i t jest punktem końcowym:

\begin{align*}
	\mli{edges}(n, E) = \left( \bigwedge_{i=0}^{n-1} \bigvee_{(s,t) \in E} (v_i = s \land v_{i+1} = t) \right)
\end{align*}

\begin{lstlisting}	
	def edge(graph: dict[int, list[int]], s, t):
	atoms = []
	for source in graph:
	for target in graph[source]:
	atoms.append(z3.And([s == source, t == target]))
	bf = z3.Or(atoms)
	return bf
\end{lstlisting}
\vspace{1cm}

Zatem cała formuła kodująca ścieżkę Hamiltona dla grafu skierowanego zawierającego \(n\) wierzchołków i zbiór krawędzi \(E\) jest następująca:

\begin{align*}
	\HamPath(n, E) = & \left( \bigwedge_{j=0}^{n-1} (x_j \geq 0 \land x_j < n) \right) \land 
	\left( \bigwedge_{i=0}^{n-1} \bigwedge_{j=i+1}^{n} (x_i \neq x_j) \right) \land \\ 
	& \left( \bigwedge_{i=0}^{n-1} \bigvee_{(s,t) \in E} (x_i = s \land x_{i+1} = t) \right)
\end{align*}

W implementacji głównej funkcji 'check\verb|_|hampath' wykorzystuje się strukturę danych reprezentującą graf za pomocą słownika, gdzie klucze odpowiadają wierzchołkom, a wartości są listami sąsiedztwa.

\textbf{Inicjalizacja zmiennych: } na początku funkcja wyznacza liczbę wierzchołków grafu 'n' na podstawie jego rozmiaru; tworzy wektor zmiennych całkowitoliczbowych 'vertices' za pomocą funkcji 'z3.IntVector', gdzie każda zmienna odpowiada jednemu wierzchołkowi grafu.

\begin{lstlisting}	
	def check_hampath(graph: dict[int, list[int]]):
		n = len(graph)
		vertices = z3.IntVector("v", n)
\end{lstlisting}
	
\textbf{Dodawanie ograniczeń: } dodaje wyżej opisane ograniczenia do solvera Z3.

\begin{lstlisting}
		solver.add(proper_numbers(vertices))
	
		solver.add(distinct_vs(vertices))
	
		edges = []
		for i in range(n - 1):
			edges.append(edge(graph, vertices[i], vertices[i + 1]))
		solver.add(z3.And(edges))
\end{lstlisting}

\textbf{Rozwiązywanie problemu: } solver Z3 sprawdza spełnialność wszystkich dodanych ograniczeń. Jeśli znajdzie rozwiązanie ('z3.sat'), oznacza to istnienie ścieżki Hamiltona w grafie. W przypadku braku rozwiązania, informuje o tym użytkownika.

\textbf{Prezentacja wyników: } jeśli solver znalazł rozwiązanie, funkcja wyświetla znalezioną ścieżkę Hamiltona, prezentując kolejność odwiedzania wierzchołków. W przeciwnym przypadku wyświetla wynik 'unsat'.

\begin{lstlisting}
		result = solver.check()
		if result == z3.sat:
			model = solver.model()
			vertex_values = [(idx, model[v].as_long()) for idx, v in enumerate(vertices)]
			sorted_vertices = sorted(vertex_values)
			print("Hamiltonian Path:")
			for idx, value in sorted_vertices[:-1]:
				print(f"v__{value}", end=' -> ')
			print(f"v__{sorted_vertices[-1][1]}")
		else:
			print(result)
\end{lstlisting}


\subsection{Ścieżka Hamiltona w grafie nieskierowanym}

W przypadku grafów nieskierowanych krawędzie nie mają określonego kierunku, dlatego ścieżka Hamiltona może przechodzić przez krawędź w obie strony. 

Dla grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem wierzchołków.
	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
Ścieżka Hamiltona jest sekwencją wierzchołków $v_1, v_2, …, v_n$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(v_i\) i \(v_{i+1}\) w sekwencji istnieje krawędź między \(v_i\) a \(v_{i+1}\) w \(E\). 
\end{enumerate}

Dodatkowo, ścieżka Hamiltona może zaczynać się z dowolnego wierzchołka i kończyć w dowolnym innym wierzchołku.

W kontekście modelowania problemu ścieżki Hamiltona w grafie nieskierowanym należy zapewnić możliwość przechodzenia przez krawędź w obie strony, co można osiągnąć poprzez stworzenie formuły logicznej, która będzie uwzględniała możliwość istnienia krawędzi pomiędzy wierzchołkami w obu kierunkach:

\begin{align*}
	\UHamPath(n, E) = \left( \bigwedge_{j=0}^{n-1} (x_j \geq 0 \land x_j < n) \right) \land 
	\left( \bigwedge_{i=0}^{n-1} \bigwedge_{j=i+1}^{n} (x_i \neq x_j) \right) \land \\
	\left( \bigwedge_{i=0}^{n-1} \bigvee_{(s,t) \in E} (x_i = s \land x_{i+1} = t) \lor (x_i = t \land x_{i+1} = s) \right)
\end{align*}

Poniższy fragment kodu demonstruje sposób kodowania danego ograniczenia:

\begin{lstlisting}
	def edge(graph: dict[int, list[int]], s, t):
		atoms = []
		for source in graph:
			for target in graph[source]:
				atoms.append(z3.And([s == source, t == target])) 
				atoms.append(z3.And([s == target, t == source]))
		bf = z3.Or(atoms)
		z3.simplify(bf)
		return bf
\end{lstlisting}

\section{Problem k-kliki w grafie nieskierowanym}

Klika w grafie nieskierowanym \(G\) to pełny podgraf, czyli taki, w którym każde dwa wierzchołki są połączone krawędzią. Problem kliki polega na sprawdzeniu, czy graf zwiera klikę o określonym rozmiarze \cite{Sipser0086373}. 

Dla grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem wierzchołków.
	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
K-kliką w grafie \(G\) jest podzbiór $C \subseteq V$ taki, że:
\begin{enumerate}
	\item Dla każdej pary wierzchołków \(u\) i \(v\) w \(C\) istnieje krawędź między \(u\) a \(v\) w \(E\), tj. ${u, v}\in E$. 
	\item Suma wierzchołków w \(C\) musi być równa \(k\).
\end{enumerate}

\begin{align*}
	\KCLIQUE(n, k) = &\left( \bigwedge_{j=1}^{n} (x_j \geq 1 \land x_j \leq n) \right) \land 
	\left( \bigwedge_{i=1}^{n} \bigwedge_{j=i+1}^{n} (x_i \neq x_j) \right) \land \\
	&\left( \bigwedge_{i=1}^{k} \bigwedge_{j=i+1}^{k} \bigvee_{(s,t) \in E} ((v_i = s \land v_j = t) \lor (v_j = s \land v_i = t)) \right)	
\end{align*}

\section{Problem maksymalnej kliki w grafie nieskierowanym}

Klika w grafie nieskierowanym \(G\) to pełny podgraf, czyli taki, w którym każde dwa wierzchołki są połączone krawędzią. Problem kliki polega na sprawdzeniu, czy graf zwiera klikę o określonym rozmiarze. Maksymalna klika to taka, która zawiera największą możliwą liczbę wierzchołków \cite{Sipser0086373}. 

Dla grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
 	\item \(V\) jest zbiorem wierzchołków.
 	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
Maksymalną kliką w grafie \(G\) jest podzbiór $C \subseteq V$ taki, że:
\begin{enumerate}
 	\item Dla każdej pary wierzchołków \(u\) i \(v\) w \(C\) istnieje krawędź między \(u\) a \(v\) w \(E\), tj. ${u, v}\in E$. 
 	\item \(C\) nie można rozszerzyć przez dodanie dowolnego wierzchołka $w\in V$ takiego, że $C \cup {w}$ tworzą klikę, tj. nie istnieje żaden wierzchołek \(w\) sąsiadujący z jakimkolwiek wierzchołkiem z \(C\), który nie występuje już w \(C\).
\end{enumerate}

\begin{align*}
	\MAXCLIQUE(n, N) = 
	\left( \bigwedge_{i=0}^{n-1} \bigwedge_{\substack{j=i+1 \\ j \notin N(i)}}^{n} ((x_i \land x_j) \implies (\lnot x_i \lor \lnot x_j)) \right)	
\end{align*}

\section{Problem maksymalnego zbioru niezależnego w grafie nieskierowanym}

Niezależny zbiór w grafie nieskierowanym jest podzbiorem wierzchołków grafu G, z których żadne dwa nie sąsiadują ze sobą. Problem maksymalnego zbioru niezależnego ma na celu obliczenie rozmiaru największego niezależnego zbioru w danym grafie. Rozmiar niezależnego zbioru to liczba zawartych w nim wierzchołków \cite{Korshunov1974}.

Dla grafu $G = (V, E)$, niezależny zbiór \(S\) jest maksymalnym jeżeli dla $v \in V$ jedno z poniższych twierdzeń jest prawdziwe \cite{maxIndSetDef}:

\begin{itemize}
	\item $v \in S$;
	\item $N(v) \cap S \neq \emptyset$, gdzie \(N(v)\) oznacza sąsiadów \(v\).
\end{itemize}

Problem maksymalnego niezależnego zbioru i jego dopełnienie, problem minimalnego pokrycia wierzchołków, są zaangażowane w dowodzenie złożoności obliczeniowej wielu problemów teoretycznych \cite{Skiena20}.



\begin{align*}
	MaxIndSet(n) = \left( \bigwedge_{j=0}^{n-1} (x_j = True) \right) \land 
	\left( \bigwedge_{i=0}^{n-1} \bigwedge_{\substack{j=i+1 \\ j \in N(i)}}^{n} (\lnot(x_i \land x_j)) \right)	
\end{align*}

\section{Pokrycie wierzchołkowe}

\begin{align*}
	VertexCover(n, E) = \left( \bigwedge_{j=0}^{n-1} (x_j = True) \right) \land 
	\left( \sum_{i=0}^{n-1} x_i\leq min\textunderscore size \right) \land 
	\left( \bigwedge_{u, v \in E} (x_u \lor x_v) \right)
\end{align*}

\section{Kolorowanie grafu}

\begin{align*}
	GraphColoring(n, N) = \left( \bigwedge_{j=0}^{n-1} (color_j \geq 0 \land color_j < 3) \right) \land 
	\left( \bigwedge_{j \in N(i)} (color_i \neq color_j) \right)
\end{align*}

\section{Izomorfizm grafów}

\begin{align*}
	GI() = \left( \bigwedge_{i=0}^{n-1} \left( \bigvee_{j=1}^{n-1} (v_i^1 \leftrightarrow v_j^2) \right) \right) 
	\land \left( \bigwedge_{(v_i^1, v_j^1) \in E_1} \left( \bigvee_{(v_p^2, v_q^2) \in E_2} ((v_i^1 \leftrightarrow v_p^2) \land (v_j^1 \leftrightarrow v_q^2)) \right) \right) \\
	\land \left( \bigwedge_{i=0}^{n-1} \left( \bigvee_{j=0}^{n-1} (v_i^2 \leftrightarrow v_j^1) \right) \right)	
\end{align*}

\section{Problem Komiwojażera}

\begin{align*}
	TSP() = \left(  \right) 
\end{align*}

\section{Drzewo Steinera}

\begin{align*}
	SteinerTree() = \left(  \right) 
\end{align*}

\section{Problem pokrycia zbioru}

\begin{align*}
	SetCover(n, m) = \left( \bigwedge_{i=0}^{n-1} (\bigvee_{j=0}^{m-1} s_j = True) \right) \land 
	min \left( \sum_{i=0}^{m-1} s_i \right) 
\end{align*}

\section{Problem sumy podzbioru}

\begin{align*}
	SubsetSum(n) = \left( \bigwedge_{j=0}^{n-1} (x_j = 0 \lor x_j = 1) \right) \land 
	\left( \sum_{i=0}^{n-1} (x_i \times s_i) = 0 \right) \land 
	\left( \sum_{i=0}^{n-1} x_i > 1 \right)
\end{align*}

\section{Problem plecakowy}

\begin{align*}
	Knapsack(n) = \left( \sum_{i=0}^{n-1} (weights[i]) \leq capacity \right) \land 
	max \left( \sum_{i=0}^{n-1} (values[i]) \right)
\end{align*}

\section{Problem najbliższego ciągu}

\begin{align*}
	ClosestStr() = \left(  \right) 
\end{align*}
