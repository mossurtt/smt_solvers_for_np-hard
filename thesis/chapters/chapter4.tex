\chapter{Kodowanie problemów}

Niniejszy rozdział wprowadza czytelnika do 10 wybranych problemów w teorii grafów i optymalizacji kombinatorycznej, takich jak:
Ścieżka Hamiltona w grafie skierowanym,
Ścieżka Hamiltona w grafie nieskierowanym, 
Maksymalnej kliki (ang. \textit{Maximum clique size problem}), 
Problem maksymalnego zbioru niezależnego (ang. \textit{Maximum Independent Set}),
Minimalnego pokrycia wierzchołkowego (ang. \textit{Minimal Vertex Cover}), 
Problem Komiwojażera (ang. \textit{Traveling salesperson problem}), 
Kolorowanie grafu, 
Problem pokrycia zbioru (ang. Set Cover), 
Problem sumy podzbioru (ang. Subset Sum), 
Problem plecakowy (ang. Knapsack problem).

Każdy problem, który analizuję w mojej pracy, jest kodowany jako zestaw ograniczeń logicznych, które definiują jego specyfikację i warunki jego rozwiązania. Wykorzystanie tego podejścia pozwala mi na elastyczne definiowanie problemów, wyrażanie ich w sposób zrozumiały dla maszyny, a także szybkie eksperymentowanie z różnymi zestawami ograniczeń oraz łatwe wprowadzanie zmian w modelach problemów.

Każda sekcja zawiera opis algorytmu oraz kod demonstracyjny w języku Python z wykorzystaniem biblioteki Z3 do rozwiązania tych problemów.

W celu optymalizacji procesu programowania oraz podniesienia czytelności kodu, przyjęto praktykę tworzenia katalogu 'utils', który pełni rolę biblioteki narzędziowej. Katalog ten zawiera pliki z zestawami użytecznych funkcji (ang. \textit{utility functions}), które powtarzają się w kodowaniu różnych problemów, umożliwiając ich wielokrotne wykorzystanie i uniknięcie redundancji. Centralizacja tych funkcji w jednym miejscu również ułatwia zrozumienie działania programów dla osób przeglądających kod. 

Pierwszy plik z katalogu 'utils' ma nazwę 'read\verb|_|input.py', który zawiera funkcje służące do wczytywania danych wejściowych w różnych formatach, co jest niezbędne dla przeprowadzenia eksperymentów.

W kolejnym pliku 'constraints.py' umieszczono funkcje generujące ograniczenia logiczne, które są wielokrotnie stosowane w modelowaniu problemów.

Pierwszą z nich jest funkcja 'proper\verb|_|numbers', która ma na celu zapewnienie, że wartości przypisane do zmiennych 'vertices' ($v_0, v_1, …, v_{n-1}$), reprezentujących wierzchołki grafu, mieszczą się w zakresie od $0$ do $n - 1$, gdzie $n$ oznacza liczbę wierzchołków w grafie. Poniższa formuła logiczna określa przypisanie odpowiednich wartości wierzchołkóm:

\begin{align*}
	\propernumbers(n) = \left( \bigwedge_{j=0}^{n-1} (v_j \geq 0 \land v_j < n) \right) 
\end{align*}

\begin{lstlisting}
	def proper_numbers(vertices):
	n = len(vertices)
	atoms = []
	for i in range(n - 1):
	atoms.append(z3.And(vertices[i] >= 0, vertices[i] < n))
	bf = z3.And(atoms)
	return bf
\end{lstlisting}
\vspace{1cm}

Kolejną funkcją jest 'distinct\verb|_|vs', która zapewnia, że każdy wierzchołek grafu jest odwiedziany dokładnie raz, czyli żadne dwa wierzchołki nie mają tej samej wartości:

\begin{align*}
	\distinctvs(n) = \left( \bigwedge_{i=0}^{n-1} \bigwedge_{j=i+1}^{n} (v_i \neq v_j) \right)
\end{align*}

\begin{lstlisting}	
	def distinct_vs(vertices):
	n = len(vertices)
	atoms = []
	for i in range(n - 1):
	for j in range(i + 1, n):
	atoms.append(vertices[i] != vertices[j])
	bf = z3.And(atoms)
	return bf
\end{lstlisting}
\vspace{1cm}

Funkcja 'dir\verb|_|edge' generuje ograniczenia logiczne dla skierowanych krawędzi między wierzchołkami na podstawie podanego grafu. Niech $v_0, v_1, …, v_{n-1}$ będą zmiennymi reprezentującymi wierzchołki grafu, a \(E\) zbiorem wszystkich krawędzi, w przypadku grafu skierowanego zbiór uporządkowanych par $(s, t)$, gdzie \(s\) oznacza punkt źródłowy krawędzi, a \(t\) jest punktem końcowym:

\begin{align*}
	\diredges(n, E) = \left( \bigwedge_{i=0}^{n-1} \bigvee_{(s,t) \in E} (v_i = s \land v_{i+1} = t) \right)
\end{align*}

\begin{lstlisting}	
	def edge(graph: dict[int, list[int]], s, t):
	atoms = []
	for source in graph:
	for target in graph[source]:
	atoms.append(z3.And([s == source, t == target]))
	bf = z3.Or(atoms)
	return bf
\end{lstlisting}

Natomiast funkcja 'edge' 

Funkcja 'wedge'

\section{Problem ścieżki Hamiltona}

Problem ścieżki Hamiltona jest zagadnieniem z zakresu teorii złożoności i teorii grafów. Rozstrzyga on, czy graf zawiera ścieżkę Hamiltona, czyli ścieżkę, która odwiedza każdy wierzchołek grafu dokładnie raz.

Problem ścieżki Hamiltona ma zastosowanie w wielu dziedzinach, takich jak informatyka, telekomunikacja czy bioinformatyka. Rozwiązanie tego problemu jest często kluczowe w analizie sieci i trasowania w systemach komunikacyjnych \cite{enwiki:1190136070}.

\subsection{Ścieżka Hamiltona w grafie skierowanym}

Dla grafu skierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem wierzchołków.
	\item \(E\) jest zbiorem skierowanych krawędzi.
\end{itemize}
Ścieżka Hamiltona jest sekwencją wierzchołków $s_0, s_1, …, s_{n-1}$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(s_i\) i \(s_{i+1}\) w sekwencji istnieje skierowana krawędź od \(s_i\) do \(s_{i+1}\) w \(E\). 
\end{enumerate}

Dodatkowo, ścieżka Hamiltona może zaczynać się z dowolnego wierzchołka i kończyć w dowolnym innym wierzchołku.

Kodowanie problemu ścieżki Hamiltona opiera się na formułowaniu ograniczeń logicznych, które muszą zostać spełnione, aby znaleźć poszukiwaną ścieżkę Hamiltona. W tym celu definiuje się cztery funkcje: 'check\verb|_|hampath', 'proper\verb|_|numbers', 'distinct\verb|_|vs' oraz 'edge'. Funkcja 'check\verb|_|hampath' odpowiada za główny algorytm rozwiązujący problem. Pozostałe funkcje służą do generowania ograniczeń logicznych.


\vspace{1cm}

Zatem cała formuła kodująca ścieżkę Hamiltona dla grafu skierowanego zawierającego \(n\) wierzchołków i zbiór krawędzi \(E\) jest następująca:

\begin{align*}
	\HamPath(n, E) = \propernumbers \land \distinctvs \land \diredges
\end{align*}

W implementacji głównej funkcji 'check\verb|_|hampath' wykorzystuje się strukturę danych reprezentującą graf za pomocą słownika, gdzie klucze odpowiadają wierzchołkom, a wartości są listami sąsiedztwa.

\textbf{Inicjalizacja zmiennych: } na początku funkcja wyznacza liczbę wierzchołków grafu 'n' na podstawie jego rozmiaru; tworzy wektor zmiennych całkowitoliczbowych 'vertices' za pomocą funkcji 'z3.IntVector', gdzie każda zmienna odpowiada jednemu wierzchołkowi grafu.

\begin{lstlisting}	
	def check_hampath(graph: dict[int, list[int]]):
		n = len(graph)
		vertices = z3.IntVector("v", n)
\end{lstlisting}
	
\textbf{Dodawanie ograniczeń: } dodaje wyżej opisane ograniczenia do solvera Z3.

\begin{lstlisting}
		solver.add(proper_numbers(vertices))
	
		solver.add(distinct_vs(vertices))
	
		edges = []
		for i in range(n - 1):
			edges.append(edge(graph, vertices[i], vertices[i + 1]))
		solver.add(z3.And(edges))
\end{lstlisting}

\textbf{Rozwiązywanie problemu: } solver Z3 sprawdza spełnialność wszystkich dodanych ograniczeń. Jeśli znajdzie rozwiązanie ('z3.sat'), oznacza to istnienie ścieżki Hamiltona w grafie. W przypadku braku rozwiązania, informuje o tym użytkownika.

\textbf{Prezentacja wyników: } jeśli solver znalazł rozwiązanie, funkcja wyświetla znalezioną ścieżkę Hamiltona, prezentując kolejność odwiedzania wierzchołków. W przeciwnym przypadku wyświetla wynik 'unsat'.

\begin{lstlisting}
		result = solver.check()
		if result == z3.sat:
			model = solver.model()
			vertex_values = [(idx, model[v].as_long()) for idx, v in enumerate(vertices)]
			sorted_vertices = sorted(vertex_values)
			print("Hamiltonian Path:")
			for idx, value in sorted_vertices[:-1]:
				print(f"v__{value}", end=' -> ')
			print(f"v__{sorted_vertices[-1][1]}")
		else:
			print(result)
\end{lstlisting}


\subsection{Ścieżka Hamiltona w grafie nieskierowanym}

W przypadku grafów nieskierowanych krawędzie nie mają określonego kierunku, dlatego ścieżka Hamiltona może przechodzić przez krawędź w obie strony. 

Dla grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem wierzchołków.
	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
Ścieżka Hamiltona jest sekwencją wierzchołków $s_1, s_2, …, s_n$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(s_i\) i \(s_{i+1}\) w sekwencji istnieje krawędź między \(s_i\) a \(s_{i+1}\) w \(E\). 
\end{enumerate}

Dodatkowo, ścieżka Hamiltona może zaczynać się z dowolnego wierzchołka i kończyć w dowolnym innym wierzchołku.

W kontekście modelowania problemu ścieżki Hamiltona w grafie nieskierowanym należy zapewnić możliwość przechodzenia przez krawędź w obie strony, co można osiągnąć poprzez stworzenie formuły logicznej, która będzie uwzględniała możliwość istnienia krawędzi pomiędzy wierzchołkami w obu kierunkach:

\begin{align*}
	\edges(n, E) = \left( \bigwedge_{i=0}^{n-1} \bigvee_{\{s,t\} \in E} (v_i = s \land v_{i+1} = t) \lor (v_i = t \land v_{i+1} = s) \right)
\end{align*}

Poniższy fragment kodu demonstruje sposób kodowania danego ograniczenia:

\begin{lstlisting}
	def edge(graph: dict[int, list[int]], s, t):
		atoms = []
		for source in graph:
			for target in graph[source]:
				atoms.append(z3.And([s == source, t == target])) 
				atoms.append(z3.And([s == target, t == source]))
		bf = z3.Or(atoms)
		z3.simplify(bf)
		return bf
\end{lstlisting}

Zatem cała formuła kodująca ścieżkę Hamiltona dla grafu nieskierowanego zawierającego \(n\) wierzchołków i zbiór krawędzi \(E\) jest następująca:

\begin{align*}
	\UHamPath(n, E) = \propernumbers \land \distinctvs \land \edges
\end{align*}


\section{Problem maksymalnej kliki w grafie nieskierowanym}

Klika w grafie nieskierowanym \(G\) to pełny podgraf, czyli taki, w którym każde dwa wierzchołki są połączone krawędzią. Problem kliki polega na sprawdzeniu, czy graf zwiera klikę o określonym rozmiarze. Maksymalna klika to taka, która zawiera największą możliwą liczbę wierzchołków \cite{Sipser0086373}. 

Dla grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
 	\item \(V\) jest zbiorem wierzchołków.
 	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
Maksymalną kliką w grafie \(G\) jest podzbiór $C \subseteq V$ taki, że:
\begin{enumerate}
 	\item Dla każdej pary wierzchołków \(s\) i \(t\) w \(C\) istnieje krawędź między \(s\) a \(t\) w \(E\), tj. $\{s, t\}\in E$. 
 	\item \(C\) nie można rozszerzyć przez dodanie dowolnego wierzchołka $w\in V$ takiego, że $C \cup \{w\}$ tworzą klikę, tj. nie istnieje żaden wierzchołek \(w\) sąsiadujący z jakimkolwiek wierzchołkiem z \(C\), który nie występuje już w \(C\).
\end{enumerate}

\begin{align*}
	&\MaxClique(n, E, k) = \propernumbers  \land \distinctvs  \land \\
	&\left( \bigwedge_{i=0}^{k-1} \bigwedge_{j=i+1}^{k} \bigvee_{\{s,t\} \in E} ((v_i = s \land v_j = t) \lor (v_j = s \land v_i = t)) \right)	
\end{align*}


\section{Problem maksymalnego zbioru niezależnego w grafie nieskierowanym}
Niezależny zbiór w grafie nieskierowanym jest podzbiorem wierzchołków grafu G, z których żadne dwa nie sąsiadują ze sobą. Problem maksymalnego zbioru niezależnego ma na celu obliczenie rozmiaru największego niezależnego zbioru w danym grafie. Rozmiar niezależnego zbioru to liczba zawartych w nim wierzchołków \cite{Korshunov1974}.

Dla grafu $G = (V, E)$, niezależny zbiór \(S\) jest maksymalnym jeżeli dla $s \in V$ jedno z poniższych twierdzeń jest prawdziwe \cite{maxIndSetDef}:

\begin{itemize}
	\item $s \in S$;
	\item $N(s) \cap S \neq \emptyset$, gdzie \(N(s)\) oznacza sąsiadów \(s\).
\end{itemize}

Problem maksymalnego niezależnego zbioru i jego dopełnienie, problem minimalnego pokrycia wierzchołkowego, są zaangażowane w dowodzenie złożoności obliczeniowej wielu problemów teoretycznych \cite{Skiena20}.

\begin{align*}
	&\MaxIndSet(n, E, k) = \propernumbers \land \distinctvs \land \\
	&\left( \bigwedge_{i=0}^{k-1} \bigwedge_{j=i+1}^{k} \bigvee_{\{s,t\} \in E} \lnot((v_i = s \land v_j = t) \lor (v_j = s \land v_i = t)) \right)	
\end{align*}


\section{Problem pokrycia wierzchołkowego}
Pokrycie wierzchołkowe grafu nieskierowanego $G = (V, E)$ to podzbiór $V' \subseteq V$ taki, że jeżeli $\{s, t\} \in E$, to $s \in V'$ lub $t \in V'$ (lub oba). To znaczy, że każdy wierzchołek "pokrywa" przylegające krawędzie, a pokrycie wierzchołkowe dla \(G\) jest zbiorem wierzchołków, który pokrywa wszystkie krawędzie z \(E\). Rozmiar pokrycia to liczba wierzchołków w nim zawartych.

Problem pokrycia wierzchołkowego polega na znalezieniu minimalnego pokrycia w danym grafie. Dla tego problemu optymalizacyjnego, odpowiadający mu problem decyzyjny zadaje pytanie czy graf ma pokrycie o danym rozmiarze \(k\) \cite{CormenLRS0023376}.

\begin{align*}
	\VertexCover&(n, E, k) = \propernumbers \land \distinctvs \land \\
	&\left( \bigwedge_{j=0}^{k-1} \bigwedge_{\{s,t\} \in E} (v_j = s \lor v_j = t) \right)	
\end{align*}


\section{Problem kolorowania grafu}
Projektanci map dążą do używania jak najmniejszej liczby kolorów podczas kolorowania krajów na mapie, z zastrzeżeniem, że jeśli dwa kraje mają wspólną granicę, muszą mieć różne kolory. Problem ten można zamodelować za pomocą grafu nieskierowanego $G = (V, E)$, w którym każdy wierzchołek reprezentuje kraj, i wierzchołki, których kraje mają wspólną granicę, ze sobą sąsiadują. Wtedy k-kolorowanie jest funkcją $c : V \implies {1, 2, …, k}$ taką, że $c(u) \neq c(v)$ dla każdej krawędzi $(u, v) \in E$. Innymi słowy, liczby $1, 2, …, k$ oznaczają \(k\) kolorów, zaś sąsiednie wierzchołki muszą mieć różne przypisane numery. Problem kolorowania grafu polega na określeniu minimalnej liczby kolorów potrzebnej do pokolorowania danego grafu.

\begin{align*}
	\GraphColoring(n, E) = \left( \bigwedge_{j=1}^{n} (c_j \geq 1 \land c_j \leq k) \right) \land 
	\left( \bigwedge_{u, v \in E} (c_u \neq c_v) \right)
\end{align*}


\section{Problem Komiwojażera}
Rozwiązanie Problemu Komiwojażera jest kluczowym zagadnieniem optymalizacyjnym, które ma szerokie zastosowanie w różnych dziedzinach, od logistyki po planowanie tras w sieciach komunikacyjnych. Jest to szczególny przypadek problemu cyklu Hamiltona, gdzie cykl ten musi minimalizować sumaryczny koszt podróży. Aby zrozumieć lepiej problem komiwojażera, warto zwrócić uwagę na definicję cyklu Hamiltona, który stanowi jego matematyczną podstawę.

Problem znalezienia cyklu hamiltonowskiego w grafie nieskierowanym jest badany od ponad stu lat. Formalnie, cykl hamiltonowski grafu nieskierowanego $G = (V, E)$ jest prostym cyklem, który zawiera każdy wierzchołek w \(V\). Mówi się, że graf, zawierający cykl Hamiltona, jest hamiltonowskim, a w przeciwnym razie jest niehamiltonowskim. Nazwa pochodzi od nazwiska W. R. Hamiltona, który opisał grę matematyczną na dwunastościanie, w której jeden z graczy wbija pięć szpilek w dowolnych pięciu kolejnych wierzchołkach, a drugi gracz musi ukończyć ścieżkę, aby utworzyć cykl zawierający wszystkie wierzchołki.

W problemie komiwojażera, komiwojażer musi odwiedzić \(n\) miast. Zamodelujmy ten problem jako kompletny graf z \(n\) wierzchołkami, tak aby komiwojażer wykonał trasę, czyli cykl hamiltonowski, odwiedzając każde miasto dokładnie raz i kończąc w mieście początkowym. Koszt podróży z miasta \(i\) do miasta \(j\) jest nieujemną liczbą całkowitą \(c(i, j)\). W wersji optymalizacyjnej problemu, zadaniem jest wybrać trasę, której sumaryczny koszt, tzn. suma wag poszczególnych krawędzi, jest minimalny.

Dla pełnego grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem etykietowanych wierzchołków.
	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
trasa o minimalnym koszcie jest sekwencją wierzchołków $s_1, s_2, …, s_n$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(s_i\) i \(s_{i+1}\) w sekwencji istnieje krawędź między \(s_i\) a \(s_{i+1}\) w \(E\).
	\item Istnieje krawędź między ostatnim \(s_n\) a pierwszym \(s_1\) wierzchołkiem w \(E\).
	\item Suma wag wszystkich krawędzi jest co najwyżej \(k\).
\end{enumerate}

\begin{align*}
	&\TSP(n, c, E, k) = \propernumbers \land \distinctvs \land \edges \land \\
	&\left( \bigvee_{\{s,t\} \in E} ((v_{n-1} = s \land v_0 = t) \lor (v_0 = s \land v_{n-1} = t)) \right) \land \\
	&\left( \bigwedge_{\{s,t\} \in E} \sum c(s,t) <= k \right)
\end{align*}


\section{Problem pokrycia zbioru}
Problem pokrycia zbioru jest zagadnieniem optymalizacyjnym, które służy do modelowania wielu sytuacji wymagających efektywnej alokacji zasobów. Odpowiednik tego problemu decyzyjnego generalizuje NP-zupełny problem pokrycia wierzchołków, co sprawia, że jest on również klasyfikowany jako problem NP-trudny.

W problemie pokrycia zbioru, rozważając zbiór \(U\) zawierający \(n\) elementów (tzw. uniwersum) oraz \(m\) podzbiorów $S_1, S_2, …, S_m$ tych elementów, celem jest znalezienie najmniejszej liczby podzbiorów koniecznych do pokrycia wszystkich elementów. Problem decyzyjny podaje także liczbę \(k\) i pytanie jest, czy istnieje pokrycie wszystkich punktów \(C\) przy użyciu \(k\) lub mniejszej liczby zbiorów.

\begin{align*}
	\SetCover(n, m) = &\left( \bigvee_{i=1}^{m} \left( \bigwedge_{x\in U} (x \in S_i) \right) \right) \land 
	\left( \bigwedge_{S_j\in C} \bigwedge_{x\in U} (x \in S_j) \right)
\end{align*}


\section{Problem sumy podzbioru}


W ogólnym sformułowaniu, problem sumy podzbiorów przyjmuje jako dane wejściowe skończony multizbiór \(S\) liczb całkowitych i całkowitą wartość docelową \(t\), a pytanie polega na rozstrzygnięciu, czy istnieje podzbiór $S' \subseteq S$, którego elementy sumują się dokładnie do t. 

Weźmiemy pod uwagę wariant problemu, w którym dane wejściowe mogą być dodatnie lub ujemne, oraz \(t = 0\)
\begin{align*}
	\SubsetSum(n) = \left( \bigwedge_{j=0}^{n-1} (x_j = 0 \lor x_j = 1) \right) \land 
	\left( \sum_{i=0}^{n-1} (x_i \times s_i) = 0 \right) \land 
	\left( \sum_{i=0}^{n-1} x_i > 1 \right)
\end{align*}


\section{Problem plecakowy}
Problem plecakowy jest zagadnieniem z zakresu optymalizacji kombinatorycznej - uogólnieniem $\SubsetSum$, w którym każdy element wejściowy ma zarówno wartość, jak i wagę. Celem jest maksymalizacja wartości z zastrzeżeniem ograniczenia na całkowitą wagę.

\begin{align*}
	\Knapsack(n, k) = \left( \sum_{i=0}^{n-1} (weights[i]) \leq capacity \right) \land 
	\left( \sum_{i=0}^{n-1} (values[i]) <= k \right)
\end{align*}


