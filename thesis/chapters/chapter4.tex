\chapter{Kodowanie problemów}

Niniejszy rozdział wprowadza czytelnika do 10 wybranych problemów w teorii grafów i optymalizacji kombinatorycznej, takich jak:
Ścieżka Hamiltona w grafie skierowanym,
Ścieżka Hamiltona w grafie nieskierowanym, 
Maksymalnej kliki (ang. \textit{Maximum clique size problem}), 
Problem maksymalnego zbioru niezależnego (ang. \textit{Maximum Independent Set}),
Minimalnego pokrycia wierzchołkowego (ang. \textit{Minimal Vertex Cover}), 
Problem Komiwojażera (ang. \textit{Traveling salesperson problem}), 
Kolorowanie grafu, 
Problem pokrycia zbioru (ang. Set Cover), 
Problem sumy podzbioru (ang. Subset Sum), 
Problem plecakowy (ang. Knapsack problem).

Każdy problem, który analizuję w mojej pracy, jest kodowany jako zestaw ograniczeń logicznych, które definiują jego specyfikację i warunki jego rozwiązania. Wykorzystanie tego podejścia pozwala mi na elastyczne definiowanie problemów, wyrażanie ich w sposób zrozumiały dla maszyny, a także szybkie eksperymentowanie z różnymi zestawami ograniczeń oraz łatwe wprowadzanie zmian w modelach problemów.

Każda sekcja zawiera opis algorytmu oraz kod demonstracyjny w języku Python z wykorzystaniem biblioteki Z3 do rozwiązania tych problemów.

W celu optymalizacji procesu programowania oraz podniesienia czytelności kodu, przyjęto praktykę tworzenia katalogu 'utils', który pełni rolę biblioteki narzędziowej. Katalog ten zawiera pliki z zestawami użytecznych funkcji (ang. \textit{utility functions}), które powtarzają się w kodowaniu różnych problemów, umożliwiając ich wielokrotne wykorzystanie i uniknięcie redundancji. Centralizacja tych funkcji w jednym miejscu również ułatwia zrozumienie działania programów dla osób przeglądających kod. 

Pierwszy plik z katalogu 'utils' ma nazwę \textit{'read\textunderscore input.py'}, i zawiera funkcje służące do odczytu danych z plików tekstowych i tworzenia odpowiednich struktur danych na ich podstawie:

Funkcja $\readgraph$(filename) odczytuje graf nieskierowany z pliku o nazwie \textit{filename}. Każda linia pliku reprezentuje krawędź grafu, gdzie liczby oddzielone spacją to numery wierzchołków połączonych krawędzią. Funkcja tworzy i zwraca słownik, gdzie klucze to numery wierzchołków, a wartości to listy sąsiedztwa.

\lstinputlisting[caption={Czytanie grafu z pliku}]{./codes/read_graph_from_file.py}
\vspace{0.5cm}

Funkcja $\readdigraph$(filename) odczytuje graf skierowany z pliku o nazwie \textit{filename}. Działa analogicznie do poprzedniej funkcji, ale tworzy graf skierowany.

\lstinputlisting[caption={Czytanie skierowanego grafu z pliku}]{./codes/read_digraph_from_file.py}
\vspace{0.5cm}

Funkcja $\readwgraph$(filename) odczytuje graf nieskierowany z wagami krawędzi z pliku o nazwie \textit{filename}. Każda linia pliku reprezentuje krawędź grafu, gdzie trzy liczby oddzielone spacją to numery wierzchołków połączonych krawędzią oraz waga tej krawędzi. Funkcja tworzy i zwraca słownik, gdzie klucze to numery wierzchołków, a wartości to listy krotek (target, weight) reprezentujących numery wierzchołków i ich wagi.

\lstinputlisting[caption={Czytanie grafu z wagami}]{./codes/read_wgraph_from_file.py}
\vspace{0.5cm}

Funkcja $\readset$(filename) odczytuje zbiór liczb całkowitych z pliku o nazwie \textit{filename}. Każda liczba w pliku powinna być oddzielona spacją. Funkcja zwraca listę zawierającą te liczby jako elementy.

\lstinputlisting[caption={Czytanie zbioru z pliku}]{./codes/read_set_from_file.py}
\vspace{1cm}

W kolejnym pliku \textit{'constraints.py'} umieszczono funkcje generujące ograniczenia logiczne, które są wielokrotnie stosowane w modelowaniu problemów.

Pierwszą z nich jest funkcja $\propernumbers$, która ma na celu zapewnienie, że wartości przypisane do zmiennych 'vertices' ($v_0, v_1, …, v_{n-1}$), reprezentujących wierzchołki grafu, mieszczą się w zakresie od $0$ do $n - 1$, gdzie $n$ oznacza liczbę wierzchołków w grafie. 

\lstinputlisting[caption={Przypisanie właściwych wartości}]{./codes/proper_numbers.py}
\vspace{0.5cm}

Kolejną funkcją jest $\distinctvs$, która zapewnia, że każdy wierzchołek grafu jest odwiedziany dokładnie raz, czyli żadne dwie zmienne \(v\) nie mają tej samej wartości:

\lstinputlisting[caption={Unikalne wartości}]{./codes/distinct_vs.py}
\vspace{0.5cm}

Funkcja $\diredge$ generuje ograniczenia logiczne dla skierowanych krawędzi między wierzchołkami na podstawie podanego grafu. Niech $v_0, v_1, …, v_{n-1}$ będą zmiennymi reprezentującymi wierzchołki grafu, a \(E\) zbiorem wszystkich krawędzi, w przypadku grafu skierowanego zbiór uporządkowanych par $(s, t)$, gdzie \(s\) oznacza punkt źródłowy krawędzi, a \(t\) jest punktem końcowym:

\lstinputlisting[caption={Krawędź skierowana}]{./codes/dir_edge.py}
\vspace{0.5cm}

Natomiast funkcja $\edge$ generuje ograniczenia dla nieskierowanych krawędzi. Dla zmiennych $v_0, v_1, …, v_{n-1}$ reprezentujących wierzchołki grafu, i zbioru wszystkich krawędzi \(E\) (w przypadku grafu nieskierowanego jest to zbiór nieuporządkowanych par $\{s, t\}$) funkcja ta przedstawia się następująco:

\lstinputlisting[caption={Krawędź nieskierowana}]{./codes/edge.py}
\vspace{0.5cm}

Funkcja $\weedge$ generuje ograniczenie dla etykietowanych nieskierowanych krawędzi pomiędzy dwoma wierzchołkami \(s\) i \(t\) w grafie, przy użyciu zmiennej \(w\) reprezentującej wagę krawędzi:

\lstinputlisting[caption={Krawędź etykietowana}]{./codes/wedge.py}

\section{Problem ścieżki Hamiltona}

Problem ścieżki Hamiltona jest zagadnieniem z zakresu teorii złożoności i teorii grafów. Rozstrzyga on, czy graf zawiera ścieżkę Hamiltona, czyli ścieżkę, która odwiedza każdy wierzchołek grafu dokładnie raz.

Nazwa pochodzi od nazwiska W. R. Hamiltona, który opisał grę matematyczną na dwunastościanie, w której jeden z graczy wbija pięć szpilek w dowolnych pięciu kolejnych wierzchołkach, a drugi gracz musi ukończyć ścieżkę, aby utworzyć cykl zawierający wszystkie wierzchołki.

Problem ścieżki Hamiltona ma zastosowanie w wielu dziedzinach, takich jak informatyka, telekomunikacja czy bioinformatyka. Rozwiązanie tego problemu jest często kluczowe w analizie sieci i trasowania w systemach komunikacyjnych \cite{enwiki:1190136070}.

\subsection{Ścieżka Hamiltona w grafie skierowanym}

Dla grafu skierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem wierzchołków.
	\item \(E\) jest zbiorem skierowanych krawędzi.
\end{itemize}
Ścieżka Hamiltona jest sekwencją wierzchołków $s_0, s_1, …, s_{n-1}$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(s_i\) i \(s_{i+1}\) w sekwencji istnieje skierowana krawędź od \(s_i\) do \(s_{i+1}\) w \(E\). 
\end{enumerate}

Dodatkowo, ścieżka Hamiltona może zaczynać się z dowolnego wierzchołka i kończyć w dowolnym innym wierzchołku.

Kodowanie problemu ścieżki Hamiltona opiera się na formułowaniu ograniczeń logicznych, które muszą zostać spełnione, aby znaleźć poszukiwaną ścieżkę Hamiltona. W tym celu stosują się trzy funkcje z katalogu 'utils': $\propernumbers$, $\distinctvs$ oraz $\diredge$, które służą do generowania ograniczeń. Funkcja $\checkhampath$ odpowiada za główny algorytm rozwiązujący problem.

Poniższe podformuły służą do zapewnienia odpowiednich warunków dla zmiennych używanych w rozwiązaniu problemu.

Przedstawione oznaczenia używane w formułach oznaczają:
\begin{itemize}
	\item \(n\) - rozmiar zbioru zmiennych, 
	\item \(v_j\) - zmienna oznaczająca wierzchołek grafu,
	\item \(E\) - zbiór krawędzi w grafie,
	\item \(s\) i \(t\) - końce krawędzi.
\end{itemize}

$\propernumbers$ gwarantuje, że każda zmienna \(v_j\) znajduje się w zakresie od \(0\) do $n − 1$, gdzie \(n\) jest rozmiarem zbioru zmiennych.

\begin{align*}
	\propernumbers = \left( \bigwedge_{j=0}^{n-1} (v_j \geq 0 \land v_j < n) \right) 
\end{align*}

$\distinctvs$ zapewnia, że każda para zmiennych \(v_i\) i \(v_j\) jest różna od siebie, eliminując powtarzające się wartości między zmiennymi.

\begin{align*}
	\distinctvs = \left( \bigwedge_{i=0}^{n-1} \bigwedge_{j=i+1}^{n} (v_i \neq v_j) \right)
\end{align*}

$\diredges$ sprawdza, czy istnieją krawędzie w grafie o zadanych wierzchołkach \(s\) i \(t\), zapewniając, że dla każdej zmiennej \(v_i\) istnieje skierowana krawędź od niej do kolejnej zmiennej \(v_{i+1}\).​

\begin{align*}
	\diredges = \left( \bigwedge_{i=0}^{n-1} \bigvee_{(s,t) \in E} (v_i = s \land v_{i+1} = t) \right)
\end{align*}

\vspace{1cm}

Zatem cała formuła kodująca ścieżkę Hamiltona dla grafu skierowanego zawierającego \(n\) wierzchołków i zbiór krawędzi \(E\) jest następująca:

\begin{align*}
	\HamPath(n, E) = \propernumbers \land \distinctvs \land \diredges
\end{align*}

W implementacji głównej funkcji $\checkhampath$ wykorzystuje się strukturę danych reprezentującą graf za pomocą słownika, gdzie klucze odpowiadają wierzchołkom, a wartości są listami sąsiedztwa.

\textbf{Inicjalizacja zmiennych: } na początku funkcja wyznacza liczbę wierzchołków grafu 'n' na podstawie jego rozmiaru; tworzy wektor zmiennych całkowitoliczbowych 'vertices' za pomocą funkcji 'z3.IntVector', gdzie każda zmienna odpowiada jednemu wierzchołkowi grafu.
	
\textbf{Dodawanie ograniczeń: } dodaje wyżej opisane ograniczenia do solvera Z3.

\textbf{Rozwiązywanie problemu: } solver Z3 sprawdza spełnialność wszystkich dodanych ograniczeń. Jeśli znajdzie rozwiązanie ('z3.sat'), oznacza to istnienie ścieżki Hamiltona w grafie. W przypadku braku rozwiązania, informuje o tym użytkownika.

\textbf{Prezentacja wyników: } jeśli solver znalazł rozwiązanie, funkcja wyświetla znalezioną ścieżkę Hamiltona, prezentując kolejność odwiedzania wierzchołków. W przeciwnym przypadku wyświetla wynik 'unsat'.

\lstinputlisting[caption={Funkcja $\checkhampath$}]{./codes/check_hampath.py}


\subsection{Ścieżka Hamiltona w grafie nieskierowanym}

W przypadku grafów nieskierowanych krawędzie nie mają określonego kierunku, dlatego ścieżka Hamiltona może przechodzić przez krawędź w obie strony. 

Dla grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem wierzchołków.
	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
Ścieżka Hamiltona jest sekwencją wierzchołków $s_1, s_2, …, s_n$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(s_i\) i \(s_{i+1}\) w sekwencji istnieje krawędź między \(s_i\) a \(s_{i+1}\) w \(E\). 
\end{enumerate}

Dodatkowo, ścieżka Hamiltona może zaczynać się z dowolnego wierzchołka i kończyć w dowolnym innym wierzchołku.

W kontekście modelowania problemu ścieżki Hamiltona w grafie nieskierowanym należy zapewnić możliwość przechodzenia przez krawędź w obie strony, co można osiągnąć poprzez stworzenie formuły logicznej, która będzie uwzględniała możliwość istnienia krawędzi w \(E\) pomiędzy wierzchołkami \(v_i\) a \(v_{i+1}\) w obu kierunkach:

\begin{align*}
	\edges = \left( \bigwedge_{i=0}^{n-1} \bigvee_{\{s,t\} \in E} (v_i = s \land v_{i+1} = t) \lor (v_i = t \land v_{i+1} = s) \right)
\end{align*}


Zatem cała formuła kodująca ścieżkę Hamiltona dla grafu nieskierowanego zawierającego \(n\) wierzchołków i zbiór krawędzi \(E\) jest następująca:

\begin{align*}
	\UHamPath(n, E) = \propernumbers \land \distinctvs \land \edges
\end{align*}


\section{Problem maksymalnej kliki w grafie nieskierowanym}

Klika w grafie nieskierowanym \(G\) to pełny podgraf, czyli taki, w którym każde dwa wierzchołki są połączone krawędzią. Problem kliki polega na sprawdzeniu, czy graf zwiera klikę o określonym rozmiarze. Maksymalna klika to taka, która zawiera największą możliwą liczbę wierzchołków \cite{Sipser0086373}. 

Dla grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
 	\item \(V\) jest zbiorem wierzchołków.
 	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
Maksymalną kliką w grafie \(G\) jest podzbiór $C \subseteq V$ taki, że:
\begin{enumerate}
 	\item Dla każdej pary wierzchołków \(s\) i \(t\) w \(C\) istnieje krawędź między \(s\) a \(t\) w \(E\), tj. $\{s, t\}\in E$. 
 	\item \(C\) nie można rozszerzyć przez dodanie dowolnego wierzchołka $w\in V$ takiego, że $C \cup \{w\}$ tworzą klikę, tj. nie istnieje żaden wierzchołek \(w\) sąsiadujący z jakimkolwiek wierzchołkiem z \(C\), który nie występuje już w \(C\).
\end{enumerate}

Formuła logiczna kodująca problem poszukiwania maksymalnej kliki zapewnia, że każda zmienna \(v_j\) ma właściwą wartość i wszystkie zmienne \(v_j\) są różne od siebie (formuły $\propernumbers$ oraz $\distinctvs$ zostały już wcześniej omówione w opisie problemu ścieżki Hamiltona (Hamiltonian Path), dlatego też nie będę ich ponownie rozważać, zgodnie z zasadą unikania nadmiernego powtórzenia.) Druga część formuły zapewnia że dla każdej pary wierzchołków \(v_i\) i \(v_j\) w zbiorze kandydatów na klikę o rozmiarze \(k\) istnieje krawędź między nimi. Ten warunek jest sprawdzany poprzez iterację przez wszystkie pary $\{s,t\}$ w zbiorze krawędzi \(E\) i sprawdzenie, czy \(v_i\) i \(v_j\) są końcami tej krawędzi.

\begin{align*}
	&\MaxClique(n, E, k) = \propernumbers  \land \distinctvs  \land \\
	&\left( \bigwedge_{i=0}^{k-1} \bigwedge_{j=i+1}^{k} \bigvee_{\{s,t\} \in E} ((v_i = s \land v_j = t) \lor (v_j = s \land v_i = t)) \right)	
\end{align*}

Funkcja $\checkclique$ przyjmuje graf graph reprezentowany jako słownik oraz liczbę całkowitą \textit{k} reprezentującą rozmiar kliki do sprawdzenia. Inicjalizuje solver Z3 i definiuje zmienne całkowite \textit{vertices} do reprezentowania wierzchołków grafu. Następnie dodaje ograniczenia, importowane z pliku \textit{constraints.py}, aby każda zmienna reprezentowała inny wierzchołek grafu: $\propernumbers$ i $\distinctvs$. Następnie generuje ograniczenia, aby zapewnić, że wybrane wierzchołki tworzą klikę o rozmiarze \textit{k}, dodając krawędzie między wszystkimi parami wierzchołków w klice. Sprawdza spełnialność ograniczeń za pomocą solvera Z3. Jeśli znaleziono przypisanie spełniające, co oznacza istnienie kliki o rozmiarze \textit{k}, wyświetla szczegóły kliki wraz z modelem uzyskanym od solvera. W przeciwnym razie informuje, że w grafie nie istnieje klika o rozmiarze k. Na koniec zapisuje stan solvera do pliku w formacie SMT-LIB dla dalszych eksperymentów.

\lstinputlisting[caption={Funkcja $\checkclique$}]{./codes/check_clique.py}

Funkcja $\main$ koordynuje proces znajdowania maksymalnej kliki w grafie odczytanym z pliku. Upewnia się, że podane są poprawne argumenty wiersza poleceń, a następnie przystępuje do odczytu grafu z określonego pliku. Iteruje po możliwych rozmiarach kliki od 2 do liczby wierzchołków w grafie. Dla każdego rozmiaru kliki \textit{k} wywołuje funkcję \textit{'check\textunderscore clique'}, aby sprawdzić, czy istnieje klika o rozmiarze \textit{k} w grafie. Jeśli taka klika \textit{k} zostanie znaleziona, funkcja wyświetla jej szczegóły wraz z modelem uzyskanym od solvera. 

Ważnym aspektem funkcji \textit{main} jest cykl $\textit{'for'}$, który iteruje po możliwych rozmiarach kliki. Wewnątrz tego cyklu, po sprawdzeniu, czy istnieje klika o aktualnym rozmiarze k, następuje sprawdzenie wyniku \textit{result}. Jeśli wynik jest inny niż sat (co oznacza, że nie znaleziono spełnienia ograniczeń), funkcja przerywa dalsze iteracje, ponieważ nie ma potrzeby kontynuowania poszukiwań. W momencie, gdy nie można znaleźć kliki o określonym rozmiarze, dalsze poszukiwania dla większych rozmiarów kliki są bezcelowe, ponieważ każda klika musiałaby zawierać wierzchołki kliki mniejszych. Dlatego przerwanie cyklu w momencie, gdy wynik jest inny niż SAT, optymalizuje działanie funkcji main i przyspiesza proces znajdowania maksymalnej kliki w grafie.

\begin{lstlisting}
	def main():
		if len(sys.argv) != 2:
			print("Usage: python3 maxclique.py <filename>")
			return
		
		filename = sys.argv[1]
		graph = read_graph_from_file(filename)
		n = len(graph)
		
		for k in range(2, n + 1):
			result, model = check_clique(graph, k)
			if result != z3.sat:
				break
\end{lstlisting}


\section{Problem maksymalnego zbioru niezależnego w grafie nieskierowanym}
Niezależny zbiór w grafie nieskierowanym jest podzbiorem wierzchołków grafu G, z których żadne dwa nie sąsiadują ze sobą. Problem maksymalnego zbioru niezależnego ma na celu obliczenie rozmiaru największego niezależnego zbioru w danym grafie. Rozmiar niezależnego zbioru to liczba zawartych w nim wierzchołków \cite{Korshunov1974}.

Problem maksymalnego niezależnego zbioru i jego dopełnienie, problem minimalnego pokrycia wierzchołkowego, są zaangażowane w dowodzenie złożoności obliczeniowej wielu problemów teoretycznych \cite{Skiena20}.

Dla grafu $G = (V, E)$, niezależny zbiór \(S\) jest maksymalnym jeżeli dla $s \in V$ jedno z poniższych twierdzeń jest prawdziwe \cite{maxIndSetDef}:

\begin{itemize}
	\item $s \in S$;
	\item $N(s) \cap S \neq \emptyset$, gdzie \(N(s)\) oznacza sąsiadów \(s\).
\end{itemize}

Formuła logiczna kodująca problem maksymalnego zbioru niezależnego składa się z trzech podformuł. Pierwsza i druga zapewniają, że każda zmienna ma właściwą wartość, a wszystkie zmienne są różne od siebie odpowiednio. Trzecia podformuła zapewnia, że dla każdej pary zmiennych \(v_i\) i \(v_j\) w zbiorze kandydatów na maksymalny zbiór niezależny o rozmiarze \(k\), nie istnieje krawędź między nimi w \(E\).

\begin{align*}
	\MaxIndSet(n, E, k) = \propernumbers \land \distinctvs  \land \\
	\left( \bigwedge_{i=0}^{k-1} \bigwedge_{j=i+1}^{k} \bigvee_{\{s,t\} \in E} \lnot((v_i = s \land v_j = t) \lor (v_j = s \land v_i = t)) \right)	
\end{align*}

Funkcja $\checkmaxindset$ przyjmuje graf oraz rozmiar potencjalnego maksymalnego zbioru niezależnego. Tworzy wektor zmiennych całkowitoliczbowych \textit{vertices}, dodaje odpowiednie ograniczenia (wszystkie wierzchołki muszą być w zakresie od 0 do n i nie mogą się powtarzać), a następnie definiuje warunki, które wykluczają istnienie krawędzi między wierzchołkami w potencjalnym zbiorze niezależnym. Po dodaniu ograniczeń solver próbuje znaleźć rozwiązanie. Po sprawdzeniu wyniku działania solvera, jeśli udało się znaleźć maksymalny zbiór niezależny, program wypisuje ten zbiór na ekranie. W przeciwnym przypadku kończy działanie, nie wypisując żadnego wyniku. Program zapisuje stan rozwiązania w pliku o formacie .smt2, co pozwala na późniejsze analizy i debugowanie.

\lstinputlisting[caption={Funkcja $\checkmaxindset$}]{./codes/check_maxindset.py}

W programie $\maxindset$ funkcja $\main$ ma analogiczną rolę do funkcji $\main$ z programu $\maxclique$. Obydwie funkcje mają taką samą strukturę kontrolną i wykonują te same czynności, ale w odniesieniu do różnych problemów. 

\begin{lstlisting}
	def main():
		if len(sys.argv) != 2:
			print("Usage: python3 maxindset.py <filename>")
			return
		
		filename = sys.argv[1]
		graph = read_graph_from_file(filename)
		n = len(graph)
		
		for k in range(2, n + 1):
			result, model = check_maxindset(graph, k)
			if result != z3.sat:
				break
\end{lstlisting}


\section{Problem pokrycia wierzchołkowego}
Pokrycie wierzchołkowe grafu nieskierowanego $G = (V, E)$ to podzbiór $V' \subseteq V$ taki, że jeżeli $\{s, t\} \in E$, to $s \in V'$ lub $t \in V'$ (lub oba). To znaczy, że każdy wierzchołek "pokrywa" przylegające krawędzie, a pokrycie wierzchołkowe dla \(G\) jest zbiorem wierzchołków, który pokrywa wszystkie krawędzie z \(E\). Rozmiar pokrycia to liczba wierzchołków w nim zawartych.

Problem pokrycia wierzchołkowego polega na znalezieniu minimalnego pokrycia w danym grafie. Dla tego problemu optymalizacyjnego, odpowiadający mu problem decyzyjny zadaje pytanie czy graf ma pokrycie o danym rozmiarze \(k\) \cite{CormenLRS0023376}.

Formuła logiczna kodująca problem pokrycia wierzchołkowego zapewnia, że każda zmienna przyjmuje właściwą wartość oraz wszystkie zmienne są różne od siebie ($\propernumbers$ oraz $\distinctvs$). Druga część formuły gwarantuje, że dla każdego wierzchołka \(v_j\) ze zbioru kandydatów na pokrycie o rozmiarze \(k\), istnieje krawędź w \(E\), której jeden z końców to wierzchołek \(v_j\). 

\begin{align*}
	\VertexCover&(n, E, k) = \propernumbers \land \distinctvs \land \\
	&\left( \bigwedge_{j=0}^{k-1} \bigwedge_{\{s,t\} \in E} (v_j = s \lor v_j = t) \right)	
\end{align*}


\section{Problem kolorowania grafu}
Projektanci map dążą do używania jak najmniejszej liczby kolorów podczas
kolorowania krajów na mapie, z zastrzeżeniem, że jeśli dwa kraje mają wspólną
granicę, muszą mieć różne kolory. Problem ten można zamodelować za pomocą grafu
nieskierowanego $G = (V, E)$, w którym każdy wierzchołek reprezentuje kraj,
i wierzchołki, których kraje mają wspólną granicę, ze sobą sąsiadują.
%Wtedy k-kolorowanie jest funkcją $c : V \implies {1, 2, …, k}$ taką, że $c(u) \neq c(v)$ dla każdej krawędzi $(u, v) \in E$. 
%AZ
Wtedy k-kolorowanie jest funkcją $c\colon V \to \{1, 2, …, k\}$ taką, że $c(u) \neq c(v)$ dla każdej krawędzi $\{u, v\} \in E$. 
Innymi słowy, liczby $1, 2, …, k$
oznaczają \(k\) kolorów, zaś sąsiednie wierzchołki muszą mieć różne przypisane
numery. Problem kolorowania grafu polega na określeniu minimalnej liczby kolorów
potrzebnej do pokolorowania danego grafu.

Formuła logiczna kodująca problem kolorowania grafu zapewnia, że każda zmienna \(c_j\) reprezentująca kolor wierzchołka \(j\) przyjmuje wartość z przedziału od \(1\) do \(k\), gdzie \(k\) to liczba kolorów. Ponadto, dla każdej krawędzi ${s, t}$ w \(E\), kolor wierzchołka \(s\) jest różny od koloru wierzchołka \(t\).

\begin{align*}
	\GraphColoring(n, E) = \left( \bigwedge_{j=1}^{n} (c_j \geq 1 \land c_j \leq k) \right) \land 
	\left( \bigwedge_{\{s,t\} \in E} (c_s \neq c_t) \right)
\end{align*}

Program $\graphcoloring$ służy do kolorowania grafu minimalną możliwą liczbą kolorów. Oto opis tego programu:

Importuje niezbędne moduły i funkcje, w tym moduł \textit{read\textunderscore input} do wczytywania grafów z plików tekstowych, bibliotekę \textit{networkx} do manipulacji grafami oraz \textit{matplotlib.pyplot} do rysowania grafów.

Definiuje funkcję $\main$, która jest punktem wejścia do programu. Sprawdza ona, czy została podana prawidłowa liczba argumentów wiersza poleceń i wczytuje nazwę pliku zawierającego graf. Następnie iteruje po różnych możliwych liczbach kolorów (od 1 do liczby wierzchołków w grafie), aby znaleźć poprawne pokolorowanie grafu. Jeśli tak, program kończy działanie i wyświetla znalezione pokolorowanie. Jeśli nie, iteruje dalej.

Ta strategia wyszukiwania do pierwszego wyniku SAT jest zastosowana ze względu na fakt, że poszukujemy minimalnej liczby kolorów potrzebnych do pokolorowania grafu. Jeśli znajdziemy rozwiązanie SAT, oznacza to, że znaleźliśmy minimalną liczbę kolorów. Wtedy możemy przerwać dalsze iteracje i zakończyć program, ponieważ nie ma potrzeby kontynuowania poszukiwań.

\begin{lstlisting}
	def main():
		if len(sys.argv) != 2:
			print("Usage: python3 graph_coloring.py <filename>")
			return
		
		filename = sys.argv[1]
		graph = read_graph_from_file(filename)
		n = len(graph)
		
		for k in range(1, n + 1):
			result, model = check_coloring(graph, k)
			if result != z3.unsat:
				break
\end{lstlisting}

Definiuje funkcję $\checkcoloring$, która sprawdza, czy można pokolorować dany graf graph za pomocą maksymalnie k kolorów. W tym celu tworzy wektor zmiennych całkowitoliczbowych \textit{vertex\textunderscore color}, reprezentujących kolor każdego wierzchołka grafu. Następnie tworzy instancję obiektu Solver z biblioteki Z3 i dodaje ograniczenia zapewniające, że każdy kolor ma wartość od 1 do k, oraz że żadne dwa sąsiednie wierzchołki nie mają tego samego koloru.

Tworzy również plik .smt2 zawierający reprezentację problemu w formacie SMT-LIB 2.0, który może być używany przez inne narzędzia do rozwiązywania problemów ograniczeń logicznych.

Następnie wywołuje metodę check() na obiekcie Solver, aby sprawdzić, czy istnieje rozwiązanie spełniające wszystkie ograniczenia. Jeśli tak, otrzymuje model kolorowania grafu i rysuje go przy użyciu biblioteki networkx, pokazując wierzchołki w różnych kolorach zgodnie z modelem. Jeśli nie, wyświetla komunikat informujący o tym, że nie znaleziono poprawnego pokolorowania grafu.

\lstinputlisting[caption={Funkcja $\checkcoloring$}]{./codes/check_coloring.py}

Funkcja \textit{draw\textunderscore graph} rysuje graf z pokolorowanymi wierzchołkami na podstawie modelu uzyskanego z rozwiązania problemu pokolorowania grafu. Najpierw tworzy obiekt grafu, dodając wierzchołki i krawędzie. Następnie przypisuje kolory wierzchołkom na podstawie modelu i rysuje graf z odpowiednimi kolorami. Ta funkcja pomaga w wizualizacji wyników pokolorowania grafu, ułatwiając ich zrozumienie.

\lstinputlisting[caption={Funkcja $\drawgraph$}]{./codes/draw_graph.py}

\section{Problem Komiwojażera}
Rozwiązanie Problemu Komiwojażera jest kluczowym zagadnieniem optymalizacyjnym, które ma szerokie zastosowanie w różnych dziedzinach, od logistyki po planowanie tras w sieciach komunikacyjnych. Jest to szczególny przypadek problemu cyklu Hamiltona, gdzie cykl ten musi minimalizować sumaryczny koszt podróży. 

Formalnie, cykl hamiltonowski grafu nieskierowanego $G = (V, E)$ jest prostym cyklem, który zawiera każdy wierzchołek w \(V\). Mówi się, że graf, zawierający cykl Hamiltona, jest hamiltonowskim, a w przeciwnym razie jest niehamiltonowskim. 

W problemie komiwojażera, komiwojażer musi odwiedzić \(n\) miast. Zamodelujmy ten problem jako kompletny graf z \(n\) wierzchołkami, tak aby komiwojażer wykonał trasę, czyli cykl hamiltonowski, odwiedzając każde miasto dokładnie raz i kończąc w mieście początkowym. Koszt podróży z miasta \(i\) do miasta \(j\) jest nieujemną liczbą całkowitą \(c(i, j)\). W wersji optymalizacyjnej problemu, zadaniem jest wybrać trasę, której sumaryczny koszt, tzn. suma wag poszczególnych krawędzi, jest minimalny.

Dla pełnego grafu nieskierowanego $G = (V, E)$, gdzie:
\begin{itemize}
	\item \(V\) jest zbiorem etykietowanych wierzchołków.
	\item \(E\) jest zbiorem krawędzi.
\end{itemize}
trasa o minimalnym koszcie jest sekwencją wierzchołków $s_1, s_2, …, s_n$ taką, że:
\begin{enumerate}
	\item Każdy wierzchołek z \(V\) występuje dokładnie raz.
	\item Dla każdej pary kolejnych wierzchołków \(s_i\) i \(s_{i+1}\) w sekwencji istnieje krawędź między \(s_i\) a \(s_{i+1}\) w \(E\).
	\item Istnieje krawędź między ostatnim \(s_n\) a pierwszym \(s_1\) wierzchołkiem w \(E\).
	\item Suma wag wszystkich krawędzi jest co najwyżej \(k\).
\end{enumerate}

Formuła logiczna kodująca problem komiwojażera zapewnia, że każda zmienna \(v_j\) reprezentująca wierzchołek w ścieżce ma właściwą wartość i wszystkie zmienne są różne od siebie (podformuły $\propernumbers$ oraz $\distinctvs$ zostały już wcześniej omówione). Podformuła $\edges$ gwarantuje, że istnieje krawędź między kolejnymi wierzchołkami w ścieżce. Dodatkowo, formuła uwzględnia warunek zamknięcia ścieżki, czyli istnienie krawędzi między ostatnim a pierwszym wierzchołkiem. Ostatnia część formuły ogranicza sumę wag krawędzi $c(s, t)$ na ścieżce do \(k\).

\begin{align*}
	&\TSP(n, c, E, k) = \propernumbers \land \distinctvs \land \edges \land \\
	&\left( \bigvee_{\{s,t\} \in E} ((v_{n-1} = s \land v_0 = t) \lor (v_0 = s \land v_{n-1} = t)) \right) \land \\
	&\left( \bigwedge_{\{s,t\} \in E} \sum c(s,t) <= k \right)
\end{align*}

Funkcja $\checktsp$ sprawdza, czy istnieje trasa komiwojażera dla danego grafu i maksymalnego kosztu k. Tworzy ona zmienne reprezentujące wierzchołki i dodaje do solvera odpowiednie ograniczenia, takie jak poprawność numerów wierzchołków i ich różnorodność.

Następnie funkcja tworzy listę krawędzi (odpowiednio zakodowanych z pomocą funkcji wedge z pliku constraints.py) reprezentujących poszczególne odcinki trasy komiwojażera w grafie. Dodaje także ograniczenie, aby suma kosztów wszystkich krawędzi była mniejsza lub równa k. Po znalezieniu rozwiązania, funkcja wyświetla trasę komiwojażera oraz koszt całej trasy.

\lstinputlisting[caption={Funkcja $\checktsp$}]{./codes/check_tsp.py}

\section{Problem pokrycia zbioru}
Problem pokrycia zbioru jest zagadnieniem optymalizacyjnym, które służy do modelowania wielu sytuacji wymagających efektywnej alokacji zasobów. Odpowiednik tego problemu decyzyjnego generalizuje NP-zupełny problem pokrycia wierzchołków, co sprawia, że jest on również klasyfikowany jako problem NP-trudny.

W problemie pokrycia zbioru, rozważając zbiór \(U\) zawierający \(n\) elementów (tzw. uniwersum) oraz \(m\) podzbiorów $S_1, S_2, …, S_m$ tych elementów, celem jest znalezienie najmniejszej liczby podzbiorów koniecznych do pokrycia wszystkich elementów. Problem decyzyjny podaje także liczbę \(k\) i pytanie jest, czy istnieje pokrycie wszystkich punktów \(C\) przy użyciu \(k\) lub mniejszej liczby zbiorów.

\begin{align*}
	\SetCover(n, m) = &\left( \bigvee_{i=1}^{m} \left( \bigwedge_{x\in U} (x \in S_i) \right) \right) \land 
	\left( \bigwedge_{S_j\in C} \bigwedge_{x\in U} (x \in S_j) \right)
\end{align*}


\section{Problem sumy podzbioru}
W ogólnym sformułowaniu, problem sumy podzbiorów przyjmuje jako dane wejściowe
skończony multizbiór liczb całkowitych $S$ i całkowitą wartość docelową $t$,
a pytanie polega na rozstrzygnięciu, czy istnieje podzbiór $S' \subseteq S$,
którego elementy sumują się dokładnie do $t$.

%\az{1. Może lepiej zostawić problem w wersji z $t$, żeby w eksperymentach skalować po $t = 1, 2, \ldots$ aż do sumy elementów zbioru $S$}

%\az{2. Trzeba przed formułą napisać czym są $x$-y oraz, że $S = \{s_0,\ldots,s_{n-1}\}$. Ponadto w formule $*$ zamiast $\times$.}

Dany $S = {s_0, s_1, \ldots, s_{n-1}}$ to zbiór liczb całkowitych. Zmienna $x_j$ oznacza, czy $s_j$ zostanie wybrane do podzbioru (jeśli $x_j = 1$) lub nie (jeśli $x_j = 0$).

Formuła logiczna problemu sumy podzbioru zapewnia, że każda zmienna $x_j$ przyjmuje wartość logiczną 0 lub 1, co reprezentuje decyzję dotyczącą wyboru liczby $s_j$ do podzbioru. Następnie formuła gwarantuje, że suma iloczynów $x_i$ i $s_i$ dla wszystkich \(k\) elementów ze zbioru $S$ jest równa wartości $t$, co odpowiada szukanemu podzbiorowi.

\begin{align*}
	\SubsetSum(n, t) = \left( \bigwedge_{j=0}^{n-1} (x_j = 0 \lor x_j = 1) \right) \land 
	\left( \sum_{i=0}^{n} (x_i * s_i) = t \right)
\end{align*}

\lstinputlisting[caption={Funkcja $\checksubsetsum$}]{./codes/check_subsetsum.py}



\section{Problem plecakowy}
Problem plecakowy jest zagadnieniem z zakresu optymalizacji kombinatorycznej - uogólnieniem $\SubsetSum$, w którym każdy element wejściowy ma zarówno wartość, jak i wagę. Celem jest maksymalizacja wartości z zastrzeżeniem ograniczenia na całkowitą wagę.

\begin{align*}
	\Knapsack(n, k) = \left( \sum_{i=0}^{n-1} (weights[i]) \leq capacity \right) \land 
	\left( \sum_{i=0}^{n-1} (values[i]) <= k \right)
\end{align*}


